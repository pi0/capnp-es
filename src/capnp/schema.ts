// This file has been automatically generated by capnp-es.
import * as $ from "capnp-es";
export const _capnpFileId = BigInt("0xa93fc509624c72d9");
/**
* Information about one of the node's parameters.
* */
export class Node_Parameter extends $.Struct {
  static readonly _capnp = {
    displayName: "Parameter",
    id: "b9521bccf10fa3b1",
    size: new $.ObjectSize(0, 1)
  };
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string {
    return "Node_Parameter_" + super.toString();
  }
}
export class Node_NestedNode extends $.Struct {
  static readonly _capnp = {
    displayName: "NestedNode",
    id: "debf55bbfa0fc242",
    size: new $.ObjectSize(8, 1)
  };
  /**
  * Unqualified symbol name.  Unlike Node.displayName, this *can* be used programmatically.
  *
  * (On Zooko's triangle, this is the node's petname according to its parent scope.)
  * */
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  /**
  * ID of the nested node.  Typically, the target node's scopeId points back to this node, but
  * robust code should avoid relying on this.
  * */
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  toString(): string {
    return "Node_NestedNode_" + super.toString();
  }
}
export class Node_SourceInfo_Member extends $.Struct {
  static readonly _capnp = {
    displayName: "Member",
    id: "c2ba9038898e1fa2",
    size: new $.ObjectSize(0, 1)
  };
  /**
  * Doc comment on the member.
  * */
  get docComment(): string {
    return $.utils.getText(0, this);
  }
  set docComment(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string {
    return "Node_SourceInfo_Member_" + super.toString();
  }
}
/**
* Additional information about a node which is not needed at runtime, but may be useful for
* documentation or debugging purposes. This is kept in a separate struct to make sure it
* doesn't accidentally get included in contexts where it is not needed. The
* `CodeGeneratorRequest` includes this information in a separate array.
* */
export class Node_SourceInfo extends $.Struct {
  static readonly Member = Node_SourceInfo_Member;
  static readonly _capnp = {
    displayName: "SourceInfo",
    id: "f38e1de3041357ae",
    size: new $.ObjectSize(8, 2)
  };
  static _Members: $.ListCtor<Node_SourceInfo_Member>;
  /**
  * ID of the Node which this info describes.
  * */
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  /**
  * The top-level doc comment for the Node.
  * */
  get docComment(): string {
    return $.utils.getText(0, this);
  }
  set docComment(value: string) {
    $.utils.setText(0, value, this);
  }
  _adoptMembers(value: $.Orphan<$.List<Node_SourceInfo_Member>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownMembers(): $.Orphan<$.List<Node_SourceInfo_Member>> {
    return $.utils.disown(this.members);
  }
  /**
  * Information about each member -- i.e. fields (for structs), enumerants (for enums), or
  * methods (for interfaces).
  *
  * This list is the same length and order as the corresponding list in the Node, i.e.
  * Node.struct.fields, Node.enum.enumerants, or Node.interface.methods.
  * */
  get members(): $.List<Node_SourceInfo_Member> {
    return $.utils.getList(1, Node_SourceInfo._Members, this);
  }
  _hasMembers(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initMembers(length: number): $.List<Node_SourceInfo_Member> {
    return $.utils.initList(1, Node_SourceInfo._Members, length, this);
  }
  set members(value: $.List<Node_SourceInfo_Member>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string {
    return "Node_SourceInfo_" + super.toString();
  }
}
export class Node_Struct extends $.Struct {
  static readonly _capnp = {
    displayName: "struct",
    id: "9ea0b19b37fb4435",
    size: new $.ObjectSize(40, 6)
  };
  static _Fields: $.ListCtor<Field>;
  /**
  * Size of the data section, in words.
  * */
  get dataWordCount(): number {
    return $.utils.getUint16(14, this);
  }
  set dataWordCount(value: number) {
    $.utils.setUint16(14, value, this);
  }
  /**
  * Size of the pointer section, in pointers (which are one word each).
  * */
  get pointerCount(): number {
    return $.utils.getUint16(24, this);
  }
  set pointerCount(value: number) {
    $.utils.setUint16(24, value, this);
  }
  /**
  * The preferred element size to use when encoding a list of this struct.  If this is anything
  * other than `inlineComposite` then the struct is one word or less in size and is a candidate
  * for list packing optimization.
  * */
  get preferredListEncoding(): ElementSize {
    return $.utils.getUint16(26, this) as ElementSize;
  }
  set preferredListEncoding(value: ElementSize) {
    $.utils.setUint16(26, value, this);
  }
  /**
  * If true, then this "struct" node is actually not an independent node, but merely represents
  * some named union or group within a particular parent struct.  This node's scopeId refers
  * to the parent struct, which may itself be a union/group in yet another struct.
  *
  * All group nodes share the same dataWordCount and pointerCount as the top-level
  * struct, and their fields live in the same ordinal and offset spaces as all other fields in
  * the struct.
  *
  * Note that a named union is considered a special kind of group -- in fact, a named union
  * is exactly equivalent to a group that contains nothing but an unnamed union.
  * */
  get isGroup(): boolean {
    return $.utils.getBit(224, this);
  }
  set isGroup(value: boolean) {
    $.utils.setBit(224, value, this);
  }
  /**
  * Number of fields in this struct which are members of an anonymous union, and thus may
  * overlap.  If this is non-zero, then a 16-bit discriminant is present indicating which
  * of the overlapping fields is active.  This can never be 1 -- if it is non-zero, it must be
  * two or more.
  *
  * Note that the fields of an unnamed union are considered fields of the scope containing the
  * union -- an unnamed union is not its own group.  So, a top-level struct may contain a
  * non-zero discriminant count.  Named unions, on the other hand, are equivalent to groups
  * containing unnamed unions.  So, a named union has its own independent schema node, with
  * `isGroup` = true.
  * */
  get discriminantCount(): number {
    return $.utils.getUint16(30, this);
  }
  set discriminantCount(value: number) {
    $.utils.setUint16(30, value, this);
  }
  /**
  * If `discriminantCount` is non-zero, this is the offset of the union discriminant, in
  * multiples of 16 bits.
  * */
  get discriminantOffset(): number {
    return $.utils.getUint32(32, this);
  }
  set discriminantOffset(value: number) {
    $.utils.setUint32(32, value, this);
  }
  _adoptFields(value: $.Orphan<$.List<Field>>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownFields(): $.Orphan<$.List<Field>> {
    return $.utils.disown(this.fields);
  }
  /**
  * Fields defined within this scope (either the struct's top-level fields, or the fields of
  * a particular group; see `isGroup`).
  *
  * The fields are sorted by ordinal number, but note that because groups share the same
  * ordinal space, the field's index in this list is not necessarily exactly its ordinal.
  * On the other hand, the field's position in this list does remain the same even as the
  * protocol evolves, since it is not possible to insert or remove an earlier ordinal.
  * Therefore, for most use cases, if you want to identify a field by number, it may make the
  * most sense to use the field's index in this list rather than its ordinal.
  * */
  get fields(): $.List<Field> {
    return $.utils.getList(3, Node_Struct._Fields, this);
  }
  _hasFields(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initFields(length: number): $.List<Field> {
    return $.utils.initList(3, Node_Struct._Fields, length, this);
  }
  set fields(value: $.List<Field>) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  toString(): string {
    return "Node_Struct_" + super.toString();
  }
}
export class Node_Enum extends $.Struct {
  static readonly _capnp = {
    displayName: "enum",
    id: "b54ab3364333f598",
    size: new $.ObjectSize(40, 6)
  };
  static _Enumerants: $.ListCtor<Enumerant>;
  _adoptEnumerants(value: $.Orphan<$.List<Enumerant>>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownEnumerants(): $.Orphan<$.List<Enumerant>> {
    return $.utils.disown(this.enumerants);
  }
  /**
  * Enumerants ordered by numeric value (ordinal).
  * */
  get enumerants(): $.List<Enumerant> {
    return $.utils.getList(3, Node_Enum._Enumerants, this);
  }
  _hasEnumerants(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initEnumerants(length: number): $.List<Enumerant> {
    return $.utils.initList(3, Node_Enum._Enumerants, length, this);
  }
  set enumerants(value: $.List<Enumerant>) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  toString(): string {
    return "Node_Enum_" + super.toString();
  }
}
export class Node_Interface extends $.Struct {
  static readonly _capnp = {
    displayName: "interface",
    id: "e82753cff0c2218f",
    size: new $.ObjectSize(40, 6)
  };
  static _Methods: $.ListCtor<Method>;
  static _Superclasses: $.ListCtor<Superclass>;
  _adoptMethods(value: $.Orphan<$.List<Method>>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownMethods(): $.Orphan<$.List<Method>> {
    return $.utils.disown(this.methods);
  }
  /**
  * Methods ordered by ordinal.
  * */
  get methods(): $.List<Method> {
    return $.utils.getList(3, Node_Interface._Methods, this);
  }
  _hasMethods(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initMethods(length: number): $.List<Method> {
    return $.utils.initList(3, Node_Interface._Methods, length, this);
  }
  set methods(value: $.List<Method>) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptSuperclasses(value: $.Orphan<$.List<Superclass>>): void {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownSuperclasses(): $.Orphan<$.List<Superclass>> {
    return $.utils.disown(this.superclasses);
  }
  /**
  * Superclasses of this interface.
  * */
  get superclasses(): $.List<Superclass> {
    return $.utils.getList(4, Node_Interface._Superclasses, this);
  }
  _hasSuperclasses(): boolean {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initSuperclasses(length: number): $.List<Superclass> {
    return $.utils.initList(4, Node_Interface._Superclasses, length, this);
  }
  set superclasses(value: $.List<Superclass>) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  toString(): string {
    return "Node_Interface_" + super.toString();
  }
}
export class Node_Const extends $.Struct {
  static readonly _capnp = {
    displayName: "const",
    id: "b18aa5ac7a0d9420",
    size: new $.ObjectSize(40, 6)
  };
  _adoptType(value: $.Orphan<Type>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownType(): $.Orphan<Type> {
    return $.utils.disown(this.type);
  }
  get type(): Type {
    return $.utils.getStruct(3, Type, this);
  }
  _hasType(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initType(): Type {
    return $.utils.initStructAt(3, Type, this);
  }
  set type(value: Type) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptValue(value: $.Orphan<Value>): void {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownValue(): $.Orphan<Value> {
    return $.utils.disown(this.value);
  }
  get value(): Value {
    return $.utils.getStruct(4, Value, this);
  }
  _hasValue(): boolean {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initValue(): Value {
    return $.utils.initStructAt(4, Value, this);
  }
  set value(value: Value) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  toString(): string {
    return "Node_Const_" + super.toString();
  }
}
export class Node_Annotation extends $.Struct {
  static readonly _capnp = {
    displayName: "annotation",
    id: "ec1619d4400a0290",
    size: new $.ObjectSize(40, 6)
  };
  _adoptType(value: $.Orphan<Type>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownType(): $.Orphan<Type> {
    return $.utils.disown(this.type);
  }
  get type(): Type {
    return $.utils.getStruct(3, Type, this);
  }
  _hasType(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initType(): Type {
    return $.utils.initStructAt(3, Type, this);
  }
  set type(value: Type) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  get targetsFile(): boolean {
    return $.utils.getBit(112, this);
  }
  set targetsFile(value: boolean) {
    $.utils.setBit(112, value, this);
  }
  get targetsConst(): boolean {
    return $.utils.getBit(113, this);
  }
  set targetsConst(value: boolean) {
    $.utils.setBit(113, value, this);
  }
  get targetsEnum(): boolean {
    return $.utils.getBit(114, this);
  }
  set targetsEnum(value: boolean) {
    $.utils.setBit(114, value, this);
  }
  get targetsEnumerant(): boolean {
    return $.utils.getBit(115, this);
  }
  set targetsEnumerant(value: boolean) {
    $.utils.setBit(115, value, this);
  }
  get targetsStruct(): boolean {
    return $.utils.getBit(116, this);
  }
  set targetsStruct(value: boolean) {
    $.utils.setBit(116, value, this);
  }
  get targetsField(): boolean {
    return $.utils.getBit(117, this);
  }
  set targetsField(value: boolean) {
    $.utils.setBit(117, value, this);
  }
  get targetsUnion(): boolean {
    return $.utils.getBit(118, this);
  }
  set targetsUnion(value: boolean) {
    $.utils.setBit(118, value, this);
  }
  get targetsGroup(): boolean {
    return $.utils.getBit(119, this);
  }
  set targetsGroup(value: boolean) {
    $.utils.setBit(119, value, this);
  }
  get targetsInterface(): boolean {
    return $.utils.getBit(120, this);
  }
  set targetsInterface(value: boolean) {
    $.utils.setBit(120, value, this);
  }
  get targetsMethod(): boolean {
    return $.utils.getBit(121, this);
  }
  set targetsMethod(value: boolean) {
    $.utils.setBit(121, value, this);
  }
  get targetsParam(): boolean {
    return $.utils.getBit(122, this);
  }
  set targetsParam(value: boolean) {
    $.utils.setBit(122, value, this);
  }
  get targetsAnnotation(): boolean {
    return $.utils.getBit(123, this);
  }
  set targetsAnnotation(value: boolean) {
    $.utils.setBit(123, value, this);
  }
  toString(): string {
    return "Node_Annotation_" + super.toString();
  }
}
export const Node_Which = {
  FILE: 0,
  STRUCT: 1,
  ENUM: 2,
  INTERFACE: 3,
  CONST: 4,
  ANNOTATION: 5
} as const;
export type Node_Which = (typeof Node_Which)[keyof typeof Node_Which];
export class Node extends $.Struct {
  static readonly FILE = Node_Which.FILE;
  static readonly STRUCT = Node_Which.STRUCT;
  static readonly ENUM = Node_Which.ENUM;
  static readonly INTERFACE = Node_Which.INTERFACE;
  static readonly CONST = Node_Which.CONST;
  static readonly ANNOTATION = Node_Which.ANNOTATION;
  static readonly Parameter = Node_Parameter;
  static readonly NestedNode = Node_NestedNode;
  static readonly SourceInfo = Node_SourceInfo;
  static readonly _capnp = {
    displayName: "Node",
    id: "e682ab4cf923a417",
    size: new $.ObjectSize(40, 6)
  };
  static _Parameters: $.ListCtor<Node_Parameter>;
  static _NestedNodes: $.ListCtor<Node_NestedNode>;
  static _Annotations: $.ListCtor<Annotation>;
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  /**
  * Name to present to humans to identify this Node.  You should not attempt to parse this.  Its
  * format could change.  It is not guaranteed to be unique.
  *
  * (On Zooko's triangle, this is the node's nickname.)
  * */
  get displayName(): string {
    return $.utils.getText(0, this);
  }
  set displayName(value: string) {
    $.utils.setText(0, value, this);
  }
  /**
  * If you want a shorter version of `displayName` (just naming this node, without its surrounding
  * scope), chop off this many characters from the beginning of `displayName`.
  * */
  get displayNamePrefixLength(): number {
    return $.utils.getUint32(8, this);
  }
  set displayNamePrefixLength(value: number) {
    $.utils.setUint32(8, value, this);
  }
  /**
  * ID of the lexical parent node.  Typically, the scope node will have a NestedNode pointing back
  * at this node, but robust code should avoid relying on this (and, in fact, group nodes are not
  * listed in the outer struct's nestedNodes, since they are listed in the fields).  `scopeId` is
  * zero if the node has no parent, which is normally only the case with files, but should be
  * allowed for any kind of node (in order to make runtime type generation easier).
  * */
  get scopeId(): bigint {
    return $.utils.getUint64(16, this);
  }
  set scopeId(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  _adoptParameters(value: $.Orphan<$.List<Node_Parameter>>): void {
    $.utils.adopt(value, $.utils.getPointer(5, this));
  }
  _disownParameters(): $.Orphan<$.List<Node_Parameter>> {
    return $.utils.disown(this.parameters);
  }
  /**
  * List of nodes nested within this node, along with the names under which they were declared.
  * */
  get parameters(): $.List<Node_Parameter> {
    return $.utils.getList(5, Node._Parameters, this);
  }
  _hasParameters(): boolean {
    return !$.utils.isNull($.utils.getPointer(5, this));
  }
  _initParameters(length: number): $.List<Node_Parameter> {
    return $.utils.initList(5, Node._Parameters, length, this);
  }
  set parameters(value: $.List<Node_Parameter>) {
    $.utils.copyFrom(value, $.utils.getPointer(5, this));
  }
  /**
  * Annotations applied to this node.
  * */
  get isGeneric(): boolean {
    return $.utils.getBit(288, this);
  }
  set isGeneric(value: boolean) {
    $.utils.setBit(288, value, this);
  }
  _adoptNestedNodes(value: $.Orphan<$.List<Node_NestedNode>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownNestedNodes(): $.Orphan<$.List<Node_NestedNode>> {
    return $.utils.disown(this.nestedNodes);
  }
  get nestedNodes(): $.List<Node_NestedNode> {
    return $.utils.getList(1, Node._NestedNodes, this);
  }
  _hasNestedNodes(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initNestedNodes(length: number): $.List<Node_NestedNode> {
    return $.utils.initList(1, Node._NestedNodes, length, this);
  }
  set nestedNodes(value: $.List<Node_NestedNode>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptAnnotations(value: $.Orphan<$.List<Annotation>>): void {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownAnnotations(): $.Orphan<$.List<Annotation>> {
    return $.utils.disown(this.annotations);
  }
  get annotations(): $.List<Annotation> {
    return $.utils.getList(2, Node._Annotations, this);
  }
  _hasAnnotations(): boolean {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initAnnotations(length: number): $.List<Annotation> {
    return $.utils.initList(2, Node._Annotations, length, this);
  }
  set annotations(value: $.List<Annotation>) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  get _isFile(): boolean {
    return $.utils.getUint16(12, this) === 0;
  }
  set file(_: true) {
    $.utils.setUint16(12, 0, this);
  }
  get struct(): Node_Struct {
    $.utils.testWhich("struct", $.utils.getUint16(12, this), 1, this);
    return $.utils.getAs(Node_Struct, this);
  }
  _initStruct(): Node_Struct {
    $.utils.setUint16(12, 1, this);
    return $.utils.getAs(Node_Struct, this);
  }
  get _isStruct(): boolean {
    return $.utils.getUint16(12, this) === 1;
  }
  set struct(_: true) {
    $.utils.setUint16(12, 1, this);
  }
  get enum(): Node_Enum {
    $.utils.testWhich("enum", $.utils.getUint16(12, this), 2, this);
    return $.utils.getAs(Node_Enum, this);
  }
  _initEnum(): Node_Enum {
    $.utils.setUint16(12, 2, this);
    return $.utils.getAs(Node_Enum, this);
  }
  get _isEnum(): boolean {
    return $.utils.getUint16(12, this) === 2;
  }
  set enum(_: true) {
    $.utils.setUint16(12, 2, this);
  }
  get interface(): Node_Interface {
    $.utils.testWhich("interface", $.utils.getUint16(12, this), 3, this);
    return $.utils.getAs(Node_Interface, this);
  }
  _initInterface(): Node_Interface {
    $.utils.setUint16(12, 3, this);
    return $.utils.getAs(Node_Interface, this);
  }
  get _isInterface(): boolean {
    return $.utils.getUint16(12, this) === 3;
  }
  set interface(_: true) {
    $.utils.setUint16(12, 3, this);
  }
  /**
  * If this node is parameterized (generic), the list of parameters. Empty for non-generic types.
  * */
  get const(): Node_Const {
    $.utils.testWhich("const", $.utils.getUint16(12, this), 4, this);
    return $.utils.getAs(Node_Const, this);
  }
  _initConst(): Node_Const {
    $.utils.setUint16(12, 4, this);
    return $.utils.getAs(Node_Const, this);
  }
  get _isConst(): boolean {
    return $.utils.getUint16(12, this) === 4;
  }
  set const(_: true) {
    $.utils.setUint16(12, 4, this);
  }
  /**
  * True if this node is generic, meaning that it or one of its parent scopes has a non-empty
  * `parameters`.
  * */
  get annotation(): Node_Annotation {
    $.utils.testWhich("annotation", $.utils.getUint16(12, this), 5, this);
    return $.utils.getAs(Node_Annotation, this);
  }
  _initAnnotation(): Node_Annotation {
    $.utils.setUint16(12, 5, this);
    return $.utils.getAs(Node_Annotation, this);
  }
  get _isAnnotation(): boolean {
    return $.utils.getUint16(12, this) === 5;
  }
  set annotation(_: true) {
    $.utils.setUint16(12, 5, this);
  }
  toString(): string {
    return "Node_" + super.toString();
  }
  which(): Node_Which {
    return $.utils.getUint16(12, this) as Node_Which;
  }
}
/**
* A regular, non-group, non-fixed-list field.
* */
export class Field_Slot extends $.Struct {
  static readonly _capnp = {
    displayName: "slot",
    id: "c42305476bb4746f",
    size: new $.ObjectSize(24, 4)
  };
  /**
  * Offset, in units of the field's size, from the beginning of the section in which the field
  * resides.  E.g. for a UInt32 field, multiply this by 4 to get the byte offset from the
  * beginning of the data section.
  * */
  get offset(): number {
    return $.utils.getUint32(4, this);
  }
  set offset(value: number) {
    $.utils.setUint32(4, value, this);
  }
  _adoptType(value: $.Orphan<Type>): void {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownType(): $.Orphan<Type> {
    return $.utils.disown(this.type);
  }
  get type(): Type {
    return $.utils.getStruct(2, Type, this);
  }
  _hasType(): boolean {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initType(): Type {
    return $.utils.initStructAt(2, Type, this);
  }
  set type(value: Type) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptDefaultValue(value: $.Orphan<Value>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownDefaultValue(): $.Orphan<Value> {
    return $.utils.disown(this.defaultValue);
  }
  get defaultValue(): Value {
    return $.utils.getStruct(3, Value, this);
  }
  _hasDefaultValue(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initDefaultValue(): Value {
    return $.utils.initStructAt(3, Value, this);
  }
  set defaultValue(value: Value) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  /**
  * Whether the default value was specified explicitly.  Non-explicit default values are always
  * zero or empty values.  Usually, whether the default value was explicit shouldn't matter.
  * The main use case for this flag is for structs representing method parameters:
  * explicitly-defaulted parameters may be allowed to be omitted when calling the method.
  * */
  get hadExplicitDefault(): boolean {
    return $.utils.getBit(128, this);
  }
  set hadExplicitDefault(value: boolean) {
    $.utils.setBit(128, value, this);
  }
  toString(): string {
    return "Field_Slot_" + super.toString();
  }
}
/**
* A group.
* */
export class Field_Group extends $.Struct {
  static readonly _capnp = {
    displayName: "group",
    id: "cafccddb68db1d11",
    size: new $.ObjectSize(24, 4)
  };
  /**
  * The ID of the group's node.
  * */
  get typeId(): bigint {
    return $.utils.getUint64(16, this);
  }
  set typeId(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  toString(): string {
    return "Field_Group_" + super.toString();
  }
}
export const Field_Ordinal_Which = {
  IMPLICIT: 0,
  EXPLICIT: 1
} as const;
export type Field_Ordinal_Which = (typeof Field_Ordinal_Which)[keyof typeof Field_Ordinal_Which];
export class Field_Ordinal extends $.Struct {
  static readonly IMPLICIT = Field_Ordinal_Which.IMPLICIT;
  static readonly EXPLICIT = Field_Ordinal_Which.EXPLICIT;
  static readonly _capnp = {
    displayName: "ordinal",
    id: "bb90d5c287870be6",
    size: new $.ObjectSize(24, 4)
  };
  get _isImplicit(): boolean {
    return $.utils.getUint16(10, this) === 0;
  }
  set implicit(_: true) {
    $.utils.setUint16(10, 0, this);
  }
  /**
  * The original ordinal number given to the field.  You probably should NOT use this; if you need
  * a numeric identifier for a field, use its position within the field array for its scope.
  * The ordinal is given here mainly just so that the original schema text can be reproduced given
  * the compiled version -- i.e. so that `capnp compile -ocapnp` can do its job.
  * */
  get explicit(): number {
    $.utils.testWhich("explicit", $.utils.getUint16(10, this), 1, this);
    return $.utils.getUint16(12, this);
  }
  get _isExplicit(): boolean {
    return $.utils.getUint16(10, this) === 1;
  }
  set explicit(value: number) {
    $.utils.setUint16(10, 1, this);
    $.utils.setUint16(12, value, this);
  }
  toString(): string {
    return "Field_Ordinal_" + super.toString();
  }
  which(): Field_Ordinal_Which {
    return $.utils.getUint16(10, this) as Field_Ordinal_Which;
  }
}
export const Field_Which = {
  SLOT: 0,
  GROUP: 1
} as const;
export type Field_Which = (typeof Field_Which)[keyof typeof Field_Which];
/**
* Schema for a field of a struct.
* */
export class Field extends $.Struct {
  static readonly NO_DISCRIMINANT = 65535;
  static readonly SLOT = Field_Which.SLOT;
  static readonly GROUP = Field_Which.GROUP;
  static readonly _capnp = {
    displayName: "Field",
    id: "9aad50a41f4af45f",
    size: new $.ObjectSize(24, 4),
    defaultDiscriminantValue: $.getUint16Mask(65535)
  };
  static _Annotations: $.ListCtor<Annotation>;
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  /**
  * Indicates where this member appeared in the code, relative to other members.
  * Code ordering may have semantic relevance -- programmers tend to place related fields
  * together.  So, using code ordering makes sense in human-readable formats where ordering is
  * otherwise irrelevant, like JSON.  The values of codeOrder are tightly-packed, so the maximum
  * value is count(members) - 1.  Fields that are members of a union are only ordered relative to
  * the other members of that union, so the maximum value there is count(union.members).
  * */
  get codeOrder(): number {
    return $.utils.getUint16(0, this);
  }
  set codeOrder(value: number) {
    $.utils.setUint16(0, value, this);
  }
  _adoptAnnotations(value: $.Orphan<$.List<Annotation>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAnnotations(): $.Orphan<$.List<Annotation>> {
    return $.utils.disown(this.annotations);
  }
  get annotations(): $.List<Annotation> {
    return $.utils.getList(1, Field._Annotations, this);
  }
  _hasAnnotations(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAnnotations(length: number): $.List<Annotation> {
    return $.utils.initList(1, Field._Annotations, length, this);
  }
  set annotations(value: $.List<Annotation>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  /**
  * If the field is in a union, this is the value which the union's discriminant should take when
  * the field is active.  If the field is not in a union, this is 0xffff.
  * */
  get discriminantValue(): number {
    return $.utils.getUint16(2, this, Field._capnp.defaultDiscriminantValue);
  }
  set discriminantValue(value: number) {
    $.utils.setUint16(2, value, this, Field._capnp.defaultDiscriminantValue);
  }
  /**
  * A regular, non-group, non-fixed-list field.
  * */
  get slot(): Field_Slot {
    $.utils.testWhich("slot", $.utils.getUint16(8, this), 0, this);
    return $.utils.getAs(Field_Slot, this);
  }
  _initSlot(): Field_Slot {
    $.utils.setUint16(8, 0, this);
    return $.utils.getAs(Field_Slot, this);
  }
  get _isSlot(): boolean {
    return $.utils.getUint16(8, this) === 0;
  }
  set slot(_: true) {
    $.utils.setUint16(8, 0, this);
  }
  /**
  * A group.
  * */
  get group(): Field_Group {
    $.utils.testWhich("group", $.utils.getUint16(8, this), 1, this);
    return $.utils.getAs(Field_Group, this);
  }
  _initGroup(): Field_Group {
    $.utils.setUint16(8, 1, this);
    return $.utils.getAs(Field_Group, this);
  }
  get _isGroup(): boolean {
    return $.utils.getUint16(8, this) === 1;
  }
  set group(_: true) {
    $.utils.setUint16(8, 1, this);
  }
  get ordinal(): Field_Ordinal {
    return $.utils.getAs(Field_Ordinal, this);
  }
  _initOrdinal(): Field_Ordinal {
    return $.utils.getAs(Field_Ordinal, this);
  }
  toString(): string {
    return "Field_" + super.toString();
  }
  which(): Field_Which {
    return $.utils.getUint16(8, this) as Field_Which;
  }
}
/**
* Schema for member of an enum.
* */
export class Enumerant extends $.Struct {
  static readonly _capnp = {
    displayName: "Enumerant",
    id: "978a7cebdc549a4d",
    size: new $.ObjectSize(8, 2)
  };
  static _Annotations: $.ListCtor<Annotation>;
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  /**
  * Specifies order in which the enumerants were declared in the code.
  * Like utils.Field.codeOrder.
  * */
  get codeOrder(): number {
    return $.utils.getUint16(0, this);
  }
  set codeOrder(value: number) {
    $.utils.setUint16(0, value, this);
  }
  _adoptAnnotations(value: $.Orphan<$.List<Annotation>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAnnotations(): $.Orphan<$.List<Annotation>> {
    return $.utils.disown(this.annotations);
  }
  get annotations(): $.List<Annotation> {
    return $.utils.getList(1, Enumerant._Annotations, this);
  }
  _hasAnnotations(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAnnotations(length: number): $.List<Annotation> {
    return $.utils.initList(1, Enumerant._Annotations, length, this);
  }
  set annotations(value: $.List<Annotation>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string {
    return "Enumerant_" + super.toString();
  }
}
export class Superclass extends $.Struct {
  static readonly _capnp = {
    displayName: "Superclass",
    id: "a9962a9ed0a4d7f8",
    size: new $.ObjectSize(8, 1)
  };
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  _adoptBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.brand);
  }
  get brand(): Brand {
    return $.utils.getStruct(0, Brand, this);
  }
  _hasBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initBrand(): Brand {
    return $.utils.initStructAt(0, Brand, this);
  }
  set brand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Superclass_" + super.toString();
  }
}
/**
* Schema for method of an interface.
* */
export class Method extends $.Struct {
  static readonly _capnp = {
    displayName: "Method",
    id: "9500cce23b334d80",
    size: new $.ObjectSize(24, 5)
  };
  static _ImplicitParameters: $.ListCtor<Node_Parameter>;
  static _Annotations: $.ListCtor<Annotation>;
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  /**
  * Specifies order in which the methods were declared in the code.
  * Like utils.Field.codeOrder.
  * */
  get codeOrder(): number {
    return $.utils.getUint16(0, this);
  }
  set codeOrder(value: number) {
    $.utils.setUint16(0, value, this);
  }
  _adoptImplicitParameters(value: $.Orphan<$.List<Node_Parameter>>): void {
    $.utils.adopt(value, $.utils.getPointer(4, this));
  }
  _disownImplicitParameters(): $.Orphan<$.List<Node_Parameter>> {
    return $.utils.disown(this.implicitParameters);
  }
  /**
  * ID of the parameter struct type.  If a named parameter list was specified in the method
  * declaration (rather than a single struct parameter type) then a corresponding struct type is
  * auto-generated.  Such an auto-generated type will not be listed in the interface's
  * `nestedNodes` and its `scopeId` will be zero -- it is completely detached from the namespace.
  * (Awkwardly, it does of course inherit generic parameters from the method's scope, which makes
  * this a situation where you can't just climb the scope chain to find where a particular
  * generic parameter was introduced. Making the `scopeId` zero was a mistake.)
  * */
  get implicitParameters(): $.List<Node_Parameter> {
    return $.utils.getList(4, Method._ImplicitParameters, this);
  }
  _hasImplicitParameters(): boolean {
    return !$.utils.isNull($.utils.getPointer(4, this));
  }
  _initImplicitParameters(length: number): $.List<Node_Parameter> {
    return $.utils.initList(4, Method._ImplicitParameters, length, this);
  }
  set implicitParameters(value: $.List<Node_Parameter>) {
    $.utils.copyFrom(value, $.utils.getPointer(4, this));
  }
  /**
  * ID of the return struct type; similar to `paramStructType`.
  * */
  get paramStructType(): bigint {
    return $.utils.getUint64(8, this);
  }
  set paramStructType(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  _adoptParamBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownParamBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.paramBrand);
  }
  get paramBrand(): Brand {
    return $.utils.getStruct(2, Brand, this);
  }
  _hasParamBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initParamBrand(): Brand {
    return $.utils.initStructAt(2, Brand, this);
  }
  set paramBrand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  /**
  * Brand of param struct type.
  * */
  get resultStructType(): bigint {
    return $.utils.getUint64(16, this);
  }
  set resultStructType(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  _adoptResultBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownResultBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.resultBrand);
  }
  /**
  * Brand of result struct type.
  * */
  get resultBrand(): Brand {
    return $.utils.getStruct(3, Brand, this);
  }
  _hasResultBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initResultBrand(): Brand {
    return $.utils.initStructAt(3, Brand, this);
  }
  set resultBrand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptAnnotations(value: $.Orphan<$.List<Annotation>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownAnnotations(): $.Orphan<$.List<Annotation>> {
    return $.utils.disown(this.annotations);
  }
  /**
  * The parameters listed in [] (typically, type / generic parameters), whose bindings are intended
  * to be inferred rather than specified explicitly, although not all languages support this.
  * */
  get annotations(): $.List<Annotation> {
    return $.utils.getList(1, Method._Annotations, this);
  }
  _hasAnnotations(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initAnnotations(length: number): $.List<Annotation> {
    return $.utils.initList(1, Method._Annotations, length, this);
  }
  set annotations(value: $.List<Annotation>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string {
    return "Method_" + super.toString();
  }
}
export class Type_List extends $.Struct {
  static readonly _capnp = {
    displayName: "list",
    id: "87e739250a60ea97",
    size: new $.ObjectSize(24, 1)
  };
  _adoptElementType(value: $.Orphan<Type>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownElementType(): $.Orphan<Type> {
    return $.utils.disown(this.elementType);
  }
  get elementType(): Type {
    return $.utils.getStruct(0, Type, this);
  }
  _hasElementType(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initElementType(): Type {
    return $.utils.initStructAt(0, Type, this);
  }
  set elementType(value: Type) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Type_List_" + super.toString();
  }
}
export class Type_Enum extends $.Struct {
  static readonly _capnp = {
    displayName: "enum",
    id: "9e0e78711a7f87a9",
    size: new $.ObjectSize(24, 1)
  };
  get typeId(): bigint {
    return $.utils.getUint64(8, this);
  }
  set typeId(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  _adoptBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.brand);
  }
  get brand(): Brand {
    return $.utils.getStruct(0, Brand, this);
  }
  _hasBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initBrand(): Brand {
    return $.utils.initStructAt(0, Brand, this);
  }
  set brand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Type_Enum_" + super.toString();
  }
}
export class Type_Struct extends $.Struct {
  static readonly _capnp = {
    displayName: "struct",
    id: "ac3a6f60ef4cc6d3",
    size: new $.ObjectSize(24, 1)
  };
  get typeId(): bigint {
    return $.utils.getUint64(8, this);
  }
  set typeId(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  _adoptBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.brand);
  }
  get brand(): Brand {
    return $.utils.getStruct(0, Brand, this);
  }
  _hasBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initBrand(): Brand {
    return $.utils.initStructAt(0, Brand, this);
  }
  set brand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Type_Struct_" + super.toString();
  }
}
export class Type_Interface extends $.Struct {
  static readonly _capnp = {
    displayName: "interface",
    id: "ed8bca69f7fb0cbf",
    size: new $.ObjectSize(24, 1)
  };
  get typeId(): bigint {
    return $.utils.getUint64(8, this);
  }
  set typeId(value: bigint) {
    $.utils.setUint64(8, value, this);
  }
  _adoptBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.brand);
  }
  get brand(): Brand {
    return $.utils.getStruct(0, Brand, this);
  }
  _hasBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initBrand(): Brand {
    return $.utils.initStructAt(0, Brand, this);
  }
  set brand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Type_Interface_" + super.toString();
  }
}
export const Type_AnyPointer_Unconstrained_Which = {
  ANY_KIND: 0,
  STRUCT: 1,
  LIST: 2,
  CAPABILITY: 3
} as const;
export type Type_AnyPointer_Unconstrained_Which = (typeof Type_AnyPointer_Unconstrained_Which)[keyof typeof Type_AnyPointer_Unconstrained_Which];
/**
* A regular AnyPointer.
*
* The name "unconstrained" means as opposed to constraining it to match a type parameter.
* In retrospect this name is probably a poor choice given that it may still be constrained
* to be a struct, list, or capability.
* */
export class Type_AnyPointer_Unconstrained extends $.Struct {
  static readonly ANY_KIND = Type_AnyPointer_Unconstrained_Which.ANY_KIND;
  static readonly STRUCT = Type_AnyPointer_Unconstrained_Which.STRUCT;
  static readonly LIST = Type_AnyPointer_Unconstrained_Which.LIST;
  static readonly CAPABILITY = Type_AnyPointer_Unconstrained_Which.CAPABILITY;
  static readonly _capnp = {
    displayName: "unconstrained",
    id: "8e3b5f79fe593656",
    size: new $.ObjectSize(24, 1)
  };
  get _isAnyKind(): boolean {
    return $.utils.getUint16(10, this) === 0;
  }
  set anyKind(_: true) {
    $.utils.setUint16(10, 0, this);
  }
  get _isStruct(): boolean {
    return $.utils.getUint16(10, this) === 1;
  }
  set struct(_: true) {
    $.utils.setUint16(10, 1, this);
  }
  get _isList(): boolean {
    return $.utils.getUint16(10, this) === 2;
  }
  set list(_: true) {
    $.utils.setUint16(10, 2, this);
  }
  get _isCapability(): boolean {
    return $.utils.getUint16(10, this) === 3;
  }
  set capability(_: true) {
    $.utils.setUint16(10, 3, this);
  }
  toString(): string {
    return "Type_AnyPointer_Unconstrained_" + super.toString();
  }
  which(): Type_AnyPointer_Unconstrained_Which {
    return $.utils.getUint16(10, this) as Type_AnyPointer_Unconstrained_Which;
  }
}
/**
* This is actually a reference to a type parameter defined within this scope.
* */
export class Type_AnyPointer_Parameter extends $.Struct {
  static readonly _capnp = {
    displayName: "parameter",
    id: "9dd1f724f4614a85",
    size: new $.ObjectSize(24, 1)
  };
  /**
  * ID of the generic type whose parameter we're referencing. This should be a parent of the
  * current scope.
  * */
  get scopeId(): bigint {
    return $.utils.getUint64(16, this);
  }
  set scopeId(value: bigint) {
    $.utils.setUint64(16, value, this);
  }
  /**
  * Index of the parameter within the generic type's parameter list.
  * */
  get parameterIndex(): number {
    return $.utils.getUint16(10, this);
  }
  set parameterIndex(value: number) {
    $.utils.setUint16(10, value, this);
  }
  toString(): string {
    return "Type_AnyPointer_Parameter_" + super.toString();
  }
}
/**
* This is actually a reference to an implicit (generic) parameter of a method. The only
* legal context for this type to appear is inside Method.paramBrand or Method.resultBrand.
* */
export class Type_AnyPointer_ImplicitMethodParameter extends $.Struct {
  static readonly _capnp = {
    displayName: "implicitMethodParameter",
    id: "baefc9120c56e274",
    size: new $.ObjectSize(24, 1)
  };
  get parameterIndex(): number {
    return $.utils.getUint16(10, this);
  }
  set parameterIndex(value: number) {
    $.utils.setUint16(10, value, this);
  }
  toString(): string {
    return "Type_AnyPointer_ImplicitMethodParameter_" + super.toString();
  }
}
export const Type_AnyPointer_Which = {
  UNCONSTRAINED: 0,
  PARAMETER: 1,
  IMPLICIT_METHOD_PARAMETER: 2
} as const;
export type Type_AnyPointer_Which = (typeof Type_AnyPointer_Which)[keyof typeof Type_AnyPointer_Which];
export class Type_AnyPointer extends $.Struct {
  static readonly UNCONSTRAINED = Type_AnyPointer_Which.UNCONSTRAINED;
  static readonly PARAMETER = Type_AnyPointer_Which.PARAMETER;
  static readonly IMPLICIT_METHOD_PARAMETER = Type_AnyPointer_Which.IMPLICIT_METHOD_PARAMETER;
  static readonly _capnp = {
    displayName: "anyPointer",
    id: "c2573fe8a23e49f1",
    size: new $.ObjectSize(24, 1)
  };
  /**
  * A regular AnyPointer.
  *
  * The name "unconstrained" means as opposed to constraining it to match a type parameter.
  * In retrospect this name is probably a poor choice given that it may still be constrained
  * to be a struct, list, or capability.
  * */
  get unconstrained(): Type_AnyPointer_Unconstrained {
    $.utils.testWhich("unconstrained", $.utils.getUint16(8, this), 0, this);
    return $.utils.getAs(Type_AnyPointer_Unconstrained, this);
  }
  _initUnconstrained(): Type_AnyPointer_Unconstrained {
    $.utils.setUint16(8, 0, this);
    return $.utils.getAs(Type_AnyPointer_Unconstrained, this);
  }
  get _isUnconstrained(): boolean {
    return $.utils.getUint16(8, this) === 0;
  }
  set unconstrained(_: true) {
    $.utils.setUint16(8, 0, this);
  }
  /**
  * This is actually a reference to a type parameter defined within this scope.
  * */
  get parameter(): Type_AnyPointer_Parameter {
    $.utils.testWhich("parameter", $.utils.getUint16(8, this), 1, this);
    return $.utils.getAs(Type_AnyPointer_Parameter, this);
  }
  _initParameter(): Type_AnyPointer_Parameter {
    $.utils.setUint16(8, 1, this);
    return $.utils.getAs(Type_AnyPointer_Parameter, this);
  }
  get _isParameter(): boolean {
    return $.utils.getUint16(8, this) === 1;
  }
  set parameter(_: true) {
    $.utils.setUint16(8, 1, this);
  }
  /**
  * This is actually a reference to an implicit (generic) parameter of a method. The only
  * legal context for this type to appear is inside Method.paramBrand or Method.resultBrand.
  * */
  get implicitMethodParameter(): Type_AnyPointer_ImplicitMethodParameter {
    $.utils.testWhich("implicitMethodParameter", $.utils.getUint16(8, this), 2, this);
    return $.utils.getAs(Type_AnyPointer_ImplicitMethodParameter, this);
  }
  _initImplicitMethodParameter(): Type_AnyPointer_ImplicitMethodParameter {
    $.utils.setUint16(8, 2, this);
    return $.utils.getAs(Type_AnyPointer_ImplicitMethodParameter, this);
  }
  get _isImplicitMethodParameter(): boolean {
    return $.utils.getUint16(8, this) === 2;
  }
  set implicitMethodParameter(_: true) {
    $.utils.setUint16(8, 2, this);
  }
  toString(): string {
    return "Type_AnyPointer_" + super.toString();
  }
  which(): Type_AnyPointer_Which {
    return $.utils.getUint16(8, this) as Type_AnyPointer_Which;
  }
}
export const Type_Which = {
  VOID: 0,
  BOOL: 1,
  INT8: 2,
  INT16: 3,
  INT32: 4,
  INT64: 5,
  UINT8: 6,
  UINT16: 7,
  UINT32: 8,
  UINT64: 9,
  FLOAT32: 10,
  FLOAT64: 11,
  TEXT: 12,
  DATA: 13,
  LIST: 14,
  ENUM: 15,
  STRUCT: 16,
  INTERFACE: 17,
  ANY_POINTER: 18
} as const;
export type Type_Which = (typeof Type_Which)[keyof typeof Type_Which];
/**
* Represents a type expression.
* */
export class Type extends $.Struct {
  static readonly VOID = Type_Which.VOID;
  static readonly BOOL = Type_Which.BOOL;
  static readonly INT8 = Type_Which.INT8;
  static readonly INT16 = Type_Which.INT16;
  static readonly INT32 = Type_Which.INT32;
  static readonly INT64 = Type_Which.INT64;
  static readonly UINT8 = Type_Which.UINT8;
  static readonly UINT16 = Type_Which.UINT16;
  static readonly UINT32 = Type_Which.UINT32;
  static readonly UINT64 = Type_Which.UINT64;
  static readonly FLOAT32 = Type_Which.FLOAT32;
  static readonly FLOAT64 = Type_Which.FLOAT64;
  static readonly TEXT = Type_Which.TEXT;
  static readonly DATA = Type_Which.DATA;
  static readonly LIST = Type_Which.LIST;
  static readonly ENUM = Type_Which.ENUM;
  static readonly STRUCT = Type_Which.STRUCT;
  static readonly INTERFACE = Type_Which.INTERFACE;
  static readonly ANY_POINTER = Type_Which.ANY_POINTER;
  static readonly _capnp = {
    displayName: "Type",
    id: "d07378ede1f9cc60",
    size: new $.ObjectSize(24, 1)
  };
  get _isVoid(): boolean {
    return $.utils.getUint16(0, this) === 0;
  }
  set void(_: true) {
    $.utils.setUint16(0, 0, this);
  }
  get _isBool(): boolean {
    return $.utils.getUint16(0, this) === 1;
  }
  set bool(_: true) {
    $.utils.setUint16(0, 1, this);
  }
  get _isInt8(): boolean {
    return $.utils.getUint16(0, this) === 2;
  }
  set int8(_: true) {
    $.utils.setUint16(0, 2, this);
  }
  get _isInt16(): boolean {
    return $.utils.getUint16(0, this) === 3;
  }
  set int16(_: true) {
    $.utils.setUint16(0, 3, this);
  }
  get _isInt32(): boolean {
    return $.utils.getUint16(0, this) === 4;
  }
  set int32(_: true) {
    $.utils.setUint16(0, 4, this);
  }
  get _isInt64(): boolean {
    return $.utils.getUint16(0, this) === 5;
  }
  set int64(_: true) {
    $.utils.setUint16(0, 5, this);
  }
  get _isUint8(): boolean {
    return $.utils.getUint16(0, this) === 6;
  }
  set uint8(_: true) {
    $.utils.setUint16(0, 6, this);
  }
  get _isUint16(): boolean {
    return $.utils.getUint16(0, this) === 7;
  }
  set uint16(_: true) {
    $.utils.setUint16(0, 7, this);
  }
  get _isUint32(): boolean {
    return $.utils.getUint16(0, this) === 8;
  }
  set uint32(_: true) {
    $.utils.setUint16(0, 8, this);
  }
  get _isUint64(): boolean {
    return $.utils.getUint16(0, this) === 9;
  }
  set uint64(_: true) {
    $.utils.setUint16(0, 9, this);
  }
  get _isFloat32(): boolean {
    return $.utils.getUint16(0, this) === 10;
  }
  set float32(_: true) {
    $.utils.setUint16(0, 10, this);
  }
  get _isFloat64(): boolean {
    return $.utils.getUint16(0, this) === 11;
  }
  set float64(_: true) {
    $.utils.setUint16(0, 11, this);
  }
  get _isText(): boolean {
    return $.utils.getUint16(0, this) === 12;
  }
  set text(_: true) {
    $.utils.setUint16(0, 12, this);
  }
  get _isData(): boolean {
    return $.utils.getUint16(0, this) === 13;
  }
  set data(_: true) {
    $.utils.setUint16(0, 13, this);
  }
  get list(): Type_List {
    $.utils.testWhich("list", $.utils.getUint16(0, this), 14, this);
    return $.utils.getAs(Type_List, this);
  }
  _initList(): Type_List {
    $.utils.setUint16(0, 14, this);
    return $.utils.getAs(Type_List, this);
  }
  get _isList(): boolean {
    return $.utils.getUint16(0, this) === 14;
  }
  set list(_: true) {
    $.utils.setUint16(0, 14, this);
  }
  get enum(): Type_Enum {
    $.utils.testWhich("enum", $.utils.getUint16(0, this), 15, this);
    return $.utils.getAs(Type_Enum, this);
  }
  _initEnum(): Type_Enum {
    $.utils.setUint16(0, 15, this);
    return $.utils.getAs(Type_Enum, this);
  }
  get _isEnum(): boolean {
    return $.utils.getUint16(0, this) === 15;
  }
  set enum(_: true) {
    $.utils.setUint16(0, 15, this);
  }
  get struct(): Type_Struct {
    $.utils.testWhich("struct", $.utils.getUint16(0, this), 16, this);
    return $.utils.getAs(Type_Struct, this);
  }
  _initStruct(): Type_Struct {
    $.utils.setUint16(0, 16, this);
    return $.utils.getAs(Type_Struct, this);
  }
  get _isStruct(): boolean {
    return $.utils.getUint16(0, this) === 16;
  }
  set struct(_: true) {
    $.utils.setUint16(0, 16, this);
  }
  get interface(): Type_Interface {
    $.utils.testWhich("interface", $.utils.getUint16(0, this), 17, this);
    return $.utils.getAs(Type_Interface, this);
  }
  _initInterface(): Type_Interface {
    $.utils.setUint16(0, 17, this);
    return $.utils.getAs(Type_Interface, this);
  }
  get _isInterface(): boolean {
    return $.utils.getUint16(0, this) === 17;
  }
  set interface(_: true) {
    $.utils.setUint16(0, 17, this);
  }
  get anyPointer(): Type_AnyPointer {
    $.utils.testWhich("anyPointer", $.utils.getUint16(0, this), 18, this);
    return $.utils.getAs(Type_AnyPointer, this);
  }
  _initAnyPointer(): Type_AnyPointer {
    $.utils.setUint16(0, 18, this);
    return $.utils.getAs(Type_AnyPointer, this);
  }
  get _isAnyPointer(): boolean {
    return $.utils.getUint16(0, this) === 18;
  }
  set anyPointer(_: true) {
    $.utils.setUint16(0, 18, this);
  }
  toString(): string {
    return "Type_" + super.toString();
  }
  which(): Type_Which {
    return $.utils.getUint16(0, this) as Type_Which;
  }
}
export const Brand_Scope_Which = {
  BIND: 0,
  INHERIT: 1
} as const;
export type Brand_Scope_Which = (typeof Brand_Scope_Which)[keyof typeof Brand_Scope_Which];
export class Brand_Scope extends $.Struct {
  static readonly BIND = Brand_Scope_Which.BIND;
  static readonly INHERIT = Brand_Scope_Which.INHERIT;
  static readonly _capnp = {
    displayName: "Scope",
    id: "abd73485a9636bc9",
    size: new $.ObjectSize(16, 1)
  };
  static _Bind: $.ListCtor<Brand_Binding>;
  /**
  * ID of the scope to which these params apply.
  * */
  get scopeId(): bigint {
    return $.utils.getUint64(0, this);
  }
  set scopeId(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  _adoptBind(value: $.Orphan<$.List<Brand_Binding>>): void {
    $.utils.setUint16(8, 0, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownBind(): $.Orphan<$.List<Brand_Binding>> {
    return $.utils.disown(this.bind);
  }
  /**
  * List of parameter bindings.
  * */
  get bind(): $.List<Brand_Binding> {
    $.utils.testWhich("bind", $.utils.getUint16(8, this), 0, this);
    return $.utils.getList(0, Brand_Scope._Bind, this);
  }
  _hasBind(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initBind(length: number): $.List<Brand_Binding> {
    $.utils.setUint16(8, 0, this);
    return $.utils.initList(0, Brand_Scope._Bind, length, this);
  }
  get _isBind(): boolean {
    return $.utils.getUint16(8, this) === 0;
  }
  set bind(value: $.List<Brand_Binding>) {
    $.utils.setUint16(8, 0, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get _isInherit(): boolean {
    return $.utils.getUint16(8, this) === 1;
  }
  set inherit(_: true) {
    $.utils.setUint16(8, 1, this);
  }
  toString(): string {
    return "Brand_Scope_" + super.toString();
  }
  which(): Brand_Scope_Which {
    return $.utils.getUint16(8, this) as Brand_Scope_Which;
  }
}
export const Brand_Binding_Which = {
  UNBOUND: 0,
  TYPE: 1
} as const;
export type Brand_Binding_Which = (typeof Brand_Binding_Which)[keyof typeof Brand_Binding_Which];
export class Brand_Binding extends $.Struct {
  static readonly UNBOUND = Brand_Binding_Which.UNBOUND;
  static readonly TYPE = Brand_Binding_Which.TYPE;
  static readonly _capnp = {
    displayName: "Binding",
    id: "c863cd16969ee7fc",
    size: new $.ObjectSize(8, 1)
  };
  get _isUnbound(): boolean {
    return $.utils.getUint16(0, this) === 0;
  }
  set unbound(_: true) {
    $.utils.setUint16(0, 0, this);
  }
  _adoptType(value: $.Orphan<Type>): void {
    $.utils.setUint16(0, 1, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownType(): $.Orphan<Type> {
    return $.utils.disown(this.type);
  }
  get type(): Type {
    $.utils.testWhich("type", $.utils.getUint16(0, this), 1, this);
    return $.utils.getStruct(0, Type, this);
  }
  _hasType(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initType(): Type {
    $.utils.setUint16(0, 1, this);
    return $.utils.initStructAt(0, Type, this);
  }
  get _isType(): boolean {
    return $.utils.getUint16(0, this) === 1;
  }
  set type(value: Type) {
    $.utils.setUint16(0, 1, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Brand_Binding_" + super.toString();
  }
  which(): Brand_Binding_Which {
    return $.utils.getUint16(0, this) as Brand_Binding_Which;
  }
}
/**
* Specifies bindings for parameters of generics. Since these bindings turn a generic into a
* non-generic, we call it the "brand".
* */
export class Brand extends $.Struct {
  static readonly Scope = Brand_Scope;
  static readonly Binding = Brand_Binding;
  static readonly _capnp = {
    displayName: "Brand",
    id: "903455f06065422b",
    size: new $.ObjectSize(0, 1)
  };
  static _Scopes: $.ListCtor<Brand_Scope>;
  _adoptScopes(value: $.Orphan<$.List<Brand_Scope>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownScopes(): $.Orphan<$.List<Brand_Scope>> {
    return $.utils.disown(this.scopes);
  }
  /**
  * For each of the target type and each of its parent scopes, a parameterization may be included
  * in this list. If no parameterization is included for a particular relevant scope, then either
  * that scope has no parameters or all parameters should be considered to be `AnyPointer`.
  * */
  get scopes(): $.List<Brand_Scope> {
    return $.utils.getList(0, Brand._Scopes, this);
  }
  _hasScopes(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initScopes(length: number): $.List<Brand_Scope> {
    return $.utils.initList(0, Brand._Scopes, length, this);
  }
  set scopes(value: $.List<Brand_Scope>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Brand_" + super.toString();
  }
}
export const Value_Which = {
  VOID: 0,
  BOOL: 1,
  INT8: 2,
  INT16: 3,
  INT32: 4,
  INT64: 5,
  UINT8: 6,
  UINT16: 7,
  UINT32: 8,
  UINT64: 9,
  FLOAT32: 10,
  FLOAT64: 11,
  TEXT: 12,
  DATA: 13,
  LIST: 14,
  ENUM: 15,
  STRUCT: 16,
  INTERFACE: 17,
  ANY_POINTER: 18
} as const;
export type Value_Which = (typeof Value_Which)[keyof typeof Value_Which];
/**
* Represents a value, e.g. a field default value, constant value, or annotation value.
* */
export class Value extends $.Struct {
  static readonly VOID = Value_Which.VOID;
  static readonly BOOL = Value_Which.BOOL;
  static readonly INT8 = Value_Which.INT8;
  static readonly INT16 = Value_Which.INT16;
  static readonly INT32 = Value_Which.INT32;
  static readonly INT64 = Value_Which.INT64;
  static readonly UINT8 = Value_Which.UINT8;
  static readonly UINT16 = Value_Which.UINT16;
  static readonly UINT32 = Value_Which.UINT32;
  static readonly UINT64 = Value_Which.UINT64;
  static readonly FLOAT32 = Value_Which.FLOAT32;
  static readonly FLOAT64 = Value_Which.FLOAT64;
  static readonly TEXT = Value_Which.TEXT;
  static readonly DATA = Value_Which.DATA;
  static readonly LIST = Value_Which.LIST;
  static readonly ENUM = Value_Which.ENUM;
  static readonly STRUCT = Value_Which.STRUCT;
  static readonly INTERFACE = Value_Which.INTERFACE;
  static readonly ANY_POINTER = Value_Which.ANY_POINTER;
  static readonly _capnp = {
    displayName: "Value",
    id: "ce23dcd2d7b00c9b",
    size: new $.ObjectSize(16, 1)
  };
  get _isVoid(): boolean {
    return $.utils.getUint16(0, this) === 0;
  }
  set void(_: true) {
    $.utils.setUint16(0, 0, this);
  }
  get bool(): boolean {
    $.utils.testWhich("bool", $.utils.getUint16(0, this), 1, this);
    return $.utils.getBit(16, this);
  }
  get _isBool(): boolean {
    return $.utils.getUint16(0, this) === 1;
  }
  set bool(value: boolean) {
    $.utils.setUint16(0, 1, this);
    $.utils.setBit(16, value, this);
  }
  get int8(): number {
    $.utils.testWhich("int8", $.utils.getUint16(0, this), 2, this);
    return $.utils.getInt8(2, this);
  }
  get _isInt8(): boolean {
    return $.utils.getUint16(0, this) === 2;
  }
  set int8(value: number) {
    $.utils.setUint16(0, 2, this);
    $.utils.setInt8(2, value, this);
  }
  get int16(): number {
    $.utils.testWhich("int16", $.utils.getUint16(0, this), 3, this);
    return $.utils.getInt16(2, this);
  }
  get _isInt16(): boolean {
    return $.utils.getUint16(0, this) === 3;
  }
  set int16(value: number) {
    $.utils.setUint16(0, 3, this);
    $.utils.setInt16(2, value, this);
  }
  get int32(): number {
    $.utils.testWhich("int32", $.utils.getUint16(0, this), 4, this);
    return $.utils.getInt32(4, this);
  }
  get _isInt32(): boolean {
    return $.utils.getUint16(0, this) === 4;
  }
  set int32(value: number) {
    $.utils.setUint16(0, 4, this);
    $.utils.setInt32(4, value, this);
  }
  get int64(): bigint {
    $.utils.testWhich("int64", $.utils.getUint16(0, this), 5, this);
    return $.utils.getInt64(8, this);
  }
  get _isInt64(): boolean {
    return $.utils.getUint16(0, this) === 5;
  }
  set int64(value: bigint) {
    $.utils.setUint16(0, 5, this);
    $.utils.setInt64(8, value, this);
  }
  get uint8(): number {
    $.utils.testWhich("uint8", $.utils.getUint16(0, this), 6, this);
    return $.utils.getUint8(2, this);
  }
  get _isUint8(): boolean {
    return $.utils.getUint16(0, this) === 6;
  }
  set uint8(value: number) {
    $.utils.setUint16(0, 6, this);
    $.utils.setUint8(2, value, this);
  }
  get uint16(): number {
    $.utils.testWhich("uint16", $.utils.getUint16(0, this), 7, this);
    return $.utils.getUint16(2, this);
  }
  get _isUint16(): boolean {
    return $.utils.getUint16(0, this) === 7;
  }
  set uint16(value: number) {
    $.utils.setUint16(0, 7, this);
    $.utils.setUint16(2, value, this);
  }
  get uint32(): number {
    $.utils.testWhich("uint32", $.utils.getUint16(0, this), 8, this);
    return $.utils.getUint32(4, this);
  }
  get _isUint32(): boolean {
    return $.utils.getUint16(0, this) === 8;
  }
  set uint32(value: number) {
    $.utils.setUint16(0, 8, this);
    $.utils.setUint32(4, value, this);
  }
  get uint64(): bigint {
    $.utils.testWhich("uint64", $.utils.getUint16(0, this), 9, this);
    return $.utils.getUint64(8, this);
  }
  get _isUint64(): boolean {
    return $.utils.getUint16(0, this) === 9;
  }
  set uint64(value: bigint) {
    $.utils.setUint16(0, 9, this);
    $.utils.setUint64(8, value, this);
  }
  get float32(): number {
    $.utils.testWhich("float32", $.utils.getUint16(0, this), 10, this);
    return $.utils.getFloat32(4, this);
  }
  get _isFloat32(): boolean {
    return $.utils.getUint16(0, this) === 10;
  }
  set float32(value: number) {
    $.utils.setUint16(0, 10, this);
    $.utils.setFloat32(4, value, this);
  }
  get float64(): number {
    $.utils.testWhich("float64", $.utils.getUint16(0, this), 11, this);
    return $.utils.getFloat64(8, this);
  }
  get _isFloat64(): boolean {
    return $.utils.getUint16(0, this) === 11;
  }
  set float64(value: number) {
    $.utils.setUint16(0, 11, this);
    $.utils.setFloat64(8, value, this);
  }
  get text(): string {
    $.utils.testWhich("text", $.utils.getUint16(0, this), 12, this);
    return $.utils.getText(0, this);
  }
  get _isText(): boolean {
    return $.utils.getUint16(0, this) === 12;
  }
  set text(value: string) {
    $.utils.setUint16(0, 12, this);
    $.utils.setText(0, value, this);
  }
  _adoptData(value: $.Orphan<$.Data>): void {
    $.utils.setUint16(0, 13, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownData(): $.Orphan<$.Data> {
    return $.utils.disown(this.data);
  }
  get data(): $.Data {
    $.utils.testWhich("data", $.utils.getUint16(0, this), 13, this);
    return $.utils.getData(0, this);
  }
  _hasData(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initData(length: number): $.Data {
    $.utils.setUint16(0, 13, this);
    return $.utils.initData(0, length, this);
  }
  get _isData(): boolean {
    return $.utils.getUint16(0, this) === 13;
  }
  set data(value: $.Data) {
    $.utils.setUint16(0, 13, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptList(value: $.Orphan<$.Pointer>): void {
    $.utils.setUint16(0, 14, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownList(): $.Orphan<$.Pointer> {
    return $.utils.disown(this.list);
  }
  get list(): $.Pointer {
    $.utils.testWhich("list", $.utils.getUint16(0, this), 14, this);
    return $.utils.getPointer(0, this);
  }
  _hasList(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  get _isList(): boolean {
    return $.utils.getUint16(0, this) === 14;
  }
  set list(value: $.Pointer) {
    $.utils.setUint16(0, 14, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get enum(): number {
    $.utils.testWhich("enum", $.utils.getUint16(0, this), 15, this);
    return $.utils.getUint16(2, this);
  }
  get _isEnum(): boolean {
    return $.utils.getUint16(0, this) === 15;
  }
  set enum(value: number) {
    $.utils.setUint16(0, 15, this);
    $.utils.setUint16(2, value, this);
  }
  _adoptStruct(value: $.Orphan<$.Pointer>): void {
    $.utils.setUint16(0, 16, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownStruct(): $.Orphan<$.Pointer> {
    return $.utils.disown(this.struct);
  }
  get struct(): $.Pointer {
    $.utils.testWhich("struct", $.utils.getUint16(0, this), 16, this);
    return $.utils.getPointer(0, this);
  }
  _hasStruct(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  get _isStruct(): boolean {
    return $.utils.getUint16(0, this) === 16;
  }
  set struct(value: $.Pointer) {
    $.utils.setUint16(0, 16, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  get _isInterface(): boolean {
    return $.utils.getUint16(0, this) === 17;
  }
  set interface(_: true) {
    $.utils.setUint16(0, 17, this);
  }
  _adoptAnyPointer(value: $.Orphan<$.Pointer>): void {
    $.utils.setUint16(0, 18, this);
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownAnyPointer(): $.Orphan<$.Pointer> {
    return $.utils.disown(this.anyPointer);
  }
  get anyPointer(): $.Pointer {
    $.utils.testWhich("anyPointer", $.utils.getUint16(0, this), 18, this);
    return $.utils.getPointer(0, this);
  }
  _hasAnyPointer(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  get _isAnyPointer(): boolean {
    return $.utils.getUint16(0, this) === 18;
  }
  set anyPointer(value: $.Pointer) {
    $.utils.setUint16(0, 18, this);
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Value_" + super.toString();
  }
  which(): Value_Which {
    return $.utils.getUint16(0, this) as Value_Which;
  }
}
/**
* Describes an annotation applied to a declaration.  Note AnnotationNode describes the
* annotation's declaration, while this describes a use of the annotation.
* */
export class Annotation extends $.Struct {
  static readonly _capnp = {
    displayName: "Annotation",
    id: "f1c8950dab257542",
    size: new $.ObjectSize(8, 2)
  };
  /**
  * ID of the annotation node.
  * */
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  _adoptBrand(value: $.Orphan<Brand>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownBrand(): $.Orphan<Brand> {
    return $.utils.disown(this.brand);
  }
  get brand(): Brand {
    return $.utils.getStruct(1, Brand, this);
  }
  _hasBrand(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initBrand(): Brand {
    return $.utils.initStructAt(1, Brand, this);
  }
  set brand(value: Brand) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  _adoptValue(value: $.Orphan<Value>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownValue(): $.Orphan<Value> {
    return $.utils.disown(this.value);
  }
  /**
  * Brand of the annotation.
  *
  * Note that the annotation itself is not allowed to be parameterized, but its scope might be.
  * */
  get value(): Value {
    return $.utils.getStruct(0, Value, this);
  }
  _hasValue(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initValue(): Value {
    return $.utils.initStructAt(0, Value, this);
  }
  set value(value: Value) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  toString(): string {
    return "Annotation_" + super.toString();
  }
}
export const ElementSize = {
  EMPTY: 0,
  BIT: 1,
  BYTE: 2,
  TWO_BYTES: 3,
  FOUR_BYTES: 4,
  EIGHT_BYTES: 5,
  POINTER: 6,
  INLINE_COMPOSITE: 7
} as const;
export type ElementSize = (typeof ElementSize)[keyof typeof ElementSize];
export class CapnpVersion extends $.Struct {
  static readonly _capnp = {
    displayName: "CapnpVersion",
    id: "d85d305b7d839963",
    size: new $.ObjectSize(8, 0)
  };
  get major(): number {
    return $.utils.getUint16(0, this);
  }
  set major(value: number) {
    $.utils.setUint16(0, value, this);
  }
  get minor(): number {
    return $.utils.getUint8(2, this);
  }
  set minor(value: number) {
    $.utils.setUint8(2, value, this);
  }
  get micro(): number {
    return $.utils.getUint8(3, this);
  }
  set micro(value: number) {
    $.utils.setUint8(3, value, this);
  }
  toString(): string {
    return "CapnpVersion_" + super.toString();
  }
}
export class CodeGeneratorRequest_RequestedFile_Import extends $.Struct {
  static readonly _capnp = {
    displayName: "Import",
    id: "ae504193122357e5",
    size: new $.ObjectSize(8, 1)
  };
  /**
  * ID of the imported file.
  * */
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  /**
  * Name which *this* file used to refer to the foreign file.  This may be a relative name.
  * This information is provided because it might be useful for code generation, e.g. to
  * generate #include directives in C++.  We don't put this in Node.file because this
  * information is only meaningful at compile time anyway.
  *
  * (On Zooko's triangle, this is the import's petname according to the importing file.)
  * */
  get name(): string {
    return $.utils.getText(0, this);
  }
  set name(value: string) {
    $.utils.setText(0, value, this);
  }
  toString(): string {
    return "CodeGeneratorRequest_RequestedFile_Import_" + super.toString();
  }
}
export class CodeGeneratorRequest_RequestedFile extends $.Struct {
  static readonly Import = CodeGeneratorRequest_RequestedFile_Import;
  static readonly _capnp = {
    displayName: "RequestedFile",
    id: "cfea0eb02e810062",
    size: new $.ObjectSize(8, 2)
  };
  static _Imports: $.ListCtor<CodeGeneratorRequest_RequestedFile_Import>;
  /**
  * ID of the file.
  * */
  get id(): bigint {
    return $.utils.getUint64(0, this);
  }
  set id(value: bigint) {
    $.utils.setUint64(0, value, this);
  }
  /**
  * Name of the file as it appeared on the command-line (minus the src-prefix).  You may use
  * this to decide where to write the output.
  * */
  get filename(): string {
    return $.utils.getText(0, this);
  }
  set filename(value: string) {
    $.utils.setText(0, value, this);
  }
  _adoptImports(value: $.Orphan<$.List<CodeGeneratorRequest_RequestedFile_Import>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownImports(): $.Orphan<$.List<CodeGeneratorRequest_RequestedFile_Import>> {
    return $.utils.disown(this.imports);
  }
  /**
  * List of all imported paths seen in this file.
  * */
  get imports(): $.List<CodeGeneratorRequest_RequestedFile_Import> {
    return $.utils.getList(1, CodeGeneratorRequest_RequestedFile._Imports, this);
  }
  _hasImports(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initImports(length: number): $.List<CodeGeneratorRequest_RequestedFile_Import> {
    return $.utils.initList(1, CodeGeneratorRequest_RequestedFile._Imports, length, this);
  }
  set imports(value: $.List<CodeGeneratorRequest_RequestedFile_Import>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string {
    return "CodeGeneratorRequest_RequestedFile_" + super.toString();
  }
}
export class CodeGeneratorRequest extends $.Struct {
  static readonly RequestedFile = CodeGeneratorRequest_RequestedFile;
  static readonly _capnp = {
    displayName: "CodeGeneratorRequest",
    id: "bfc546f6210ad7ce",
    size: new $.ObjectSize(0, 4)
  };
  static _Nodes: $.ListCtor<Node>;
  static _SourceInfo: $.ListCtor<Node_SourceInfo>;
  static _RequestedFiles: $.ListCtor<CodeGeneratorRequest_RequestedFile>;
  _adoptCapnpVersion(value: $.Orphan<CapnpVersion>): void {
    $.utils.adopt(value, $.utils.getPointer(2, this));
  }
  _disownCapnpVersion(): $.Orphan<CapnpVersion> {
    return $.utils.disown(this.capnpVersion);
  }
  /**
  * All nodes parsed by the compiler, including for the files on the command line and their
  * imports.
  * */
  get capnpVersion(): CapnpVersion {
    return $.utils.getStruct(2, CapnpVersion, this);
  }
  _hasCapnpVersion(): boolean {
    return !$.utils.isNull($.utils.getPointer(2, this));
  }
  _initCapnpVersion(): CapnpVersion {
    return $.utils.initStructAt(2, CapnpVersion, this);
  }
  set capnpVersion(value: CapnpVersion) {
    $.utils.copyFrom(value, $.utils.getPointer(2, this));
  }
  _adoptNodes(value: $.Orphan<$.List<Node>>): void {
    $.utils.adopt(value, $.utils.getPointer(0, this));
  }
  _disownNodes(): $.Orphan<$.List<Node>> {
    return $.utils.disown(this.nodes);
  }
  /**
  * Files which were listed on the command line.
  * */
  get nodes(): $.List<Node> {
    return $.utils.getList(0, CodeGeneratorRequest._Nodes, this);
  }
  _hasNodes(): boolean {
    return !$.utils.isNull($.utils.getPointer(0, this));
  }
  _initNodes(length: number): $.List<Node> {
    return $.utils.initList(0, CodeGeneratorRequest._Nodes, length, this);
  }
  set nodes(value: $.List<Node>) {
    $.utils.copyFrom(value, $.utils.getPointer(0, this));
  }
  _adoptSourceInfo(value: $.Orphan<$.List<Node_SourceInfo>>): void {
    $.utils.adopt(value, $.utils.getPointer(3, this));
  }
  _disownSourceInfo(): $.Orphan<$.List<Node_SourceInfo>> {
    return $.utils.disown(this.sourceInfo);
  }
  /**
  * Version of the `capnp` executable. Generally, code generators should ignore this, but the code
  * generators that ship with `capnp` itself will print a warning if this mismatches since that
  * probably indicates something is misconfigured.
  *
  * The first version of 'capnp' to set this was 0.6.0. So, if it's missing, the compiler version
  * is older than that.
  * */
  get sourceInfo(): $.List<Node_SourceInfo> {
    return $.utils.getList(3, CodeGeneratorRequest._SourceInfo, this);
  }
  _hasSourceInfo(): boolean {
    return !$.utils.isNull($.utils.getPointer(3, this));
  }
  _initSourceInfo(length: number): $.List<Node_SourceInfo> {
    return $.utils.initList(3, CodeGeneratorRequest._SourceInfo, length, this);
  }
  set sourceInfo(value: $.List<Node_SourceInfo>) {
    $.utils.copyFrom(value, $.utils.getPointer(3, this));
  }
  _adoptRequestedFiles(value: $.Orphan<$.List<CodeGeneratorRequest_RequestedFile>>): void {
    $.utils.adopt(value, $.utils.getPointer(1, this));
  }
  _disownRequestedFiles(): $.Orphan<$.List<CodeGeneratorRequest_RequestedFile>> {
    return $.utils.disown(this.requestedFiles);
  }
  /**
  * Information about the original source code for each node, where available. This array may be
  * omitted or may be missing some nodes if no info is available for them.
  * */
  get requestedFiles(): $.List<CodeGeneratorRequest_RequestedFile> {
    return $.utils.getList(1, CodeGeneratorRequest._RequestedFiles, this);
  }
  _hasRequestedFiles(): boolean {
    return !$.utils.isNull($.utils.getPointer(1, this));
  }
  _initRequestedFiles(length: number): $.List<CodeGeneratorRequest_RequestedFile> {
    return $.utils.initList(1, CodeGeneratorRequest._RequestedFiles, length, this);
  }
  set requestedFiles(value: $.List<CodeGeneratorRequest_RequestedFile>) {
    $.utils.copyFrom(value, $.utils.getPointer(1, this));
  }
  toString(): string {
    return "CodeGeneratorRequest_" + super.toString();
  }
}
Node_SourceInfo._Members = $.CompositeList(Node_SourceInfo_Member);
Node_Struct._Fields = $.CompositeList(Field);
Node_Enum._Enumerants = $.CompositeList(Enumerant);
Node_Interface._Methods = $.CompositeList(Method);
Node_Interface._Superclasses = $.CompositeList(Superclass);
Node._Parameters = $.CompositeList(Node_Parameter);
Node._NestedNodes = $.CompositeList(Node_NestedNode);
Node._Annotations = $.CompositeList(Annotation);
Field._Annotations = $.CompositeList(Annotation);
Enumerant._Annotations = $.CompositeList(Annotation);
Method._ImplicitParameters = $.CompositeList(Node_Parameter);
Method._Annotations = $.CompositeList(Annotation);
Brand_Scope._Bind = $.CompositeList(Brand_Binding);
Brand._Scopes = $.CompositeList(Brand_Scope);
CodeGeneratorRequest_RequestedFile._Imports = $.CompositeList(CodeGeneratorRequest_RequestedFile_Import);
CodeGeneratorRequest._Nodes = $.CompositeList(Node);
CodeGeneratorRequest._SourceInfo = $.CompositeList(Node_SourceInfo);
CodeGeneratorRequest._RequestedFiles = $.CompositeList(CodeGeneratorRequest_RequestedFile);
